import{nq as q,aP as D,fe as C,dm as O,n$ as G,fs as F,nX as X,eU as j,ch as A,g as B,b as P,m,c as J}from"./index-CfYeSufM.js";import{a as K}from"./dehydratedFeatureComparison-Cqp8Y6mL.js";import{w as Q}from"./InteractiveToolBase-XZur83Y0.js";class V{constructor(t){this.vertexHandle=null,this.excludeFeature=null,this.visualizer=null,this.selfSnappingZ=null,this.drawConstraints=null,this.editGeometryOperations=t.editGeometryOperations,this.elevationInfo=t.elevationInfo,this.pointer=t.pointer,this.vertexHandle=t.vertexHandle,this.excludeFeature=t.excludeFeature,this.feature=t.feature,this.visualizer=t.visualizer,this.selfSnappingZ=t.selfSnappingZ,this.drawConstraints=t.drawConstraints}get coordinateHelper(){return this.editGeometryOperations.data.coordinateHelper}get spatialReference(){return this.coordinateHelper.spatialReference}}function at({predicate:n=()=>!0,snappingManager:t,snappingContext:e,updatingHandles:i,useZ:s=!0}){const o=new Q;if(t==null)return{snappingStep:[I,o],cancelSnapping:I};let r,p=null,a=null,c=null;const d=()=>{p=C(p),t.doneSnapping(),a==null||a.frameTask.remove(),a=null,r=O(r),c=null},v=W(t,s,o);let h=null,u=null,b=null;return{snappingStep:[l=>{if(!n(l))return l;const{action:_}=l;if(_==="start"){const{info:x}=l,y=Y(t.view);if(a=tt(e,l,y),a.context.selfSnappingZ=null,!s&&x!=null){const g=et(e.coordinateHelper,x.handle.component);g!=null&&(a.context.selfSnappingZ={value:g,elevationInfo:e.elevationInfo??q})}}if(a!=null){const{context:x,originalScenePos:y,originalPos:g}=a,{mapEnd:k,mapStart:Z,scenePoints:U}=l,S=N(g,T(k,Z)),z=T(Z,g),E={...l,action:"update"},M=a.context,w=nt(y,U),H=t.update({point:S,scenePoint:w,context:x});if(b=H,R(k,H,z,s),h=S,u=w,_!=="end"){const{frameTask:$}=a;p==null&&(p=new AbortController),c=L=>{i.addPromise(j(v({frameTask:$,event:E,context:M,point:S,scenePoint:w,delta:z,getLastState:()=>({point:h,scenePoint:u,updatePoint:L.forceUpdate?null:b})},p.signal)))},c({forceUpdate:!1}),r==null&&(r=D(()=>t.options.effectiveEnabled,()=>c==null?void 0:c({forceUpdate:!0})))}}return _==="end"&&d(),l},o],cancelSnapping:l=>(d(),l)}}function W(n,t,e){return A(async({frameTask:i,point:s,scenePoint:o,context:r,event:p,delta:a,getLastState:c},d)=>{const v=await i.schedule(()=>n.snap({point:s,scenePoint:o,context:r,signal:d}),d);if(v.valid){let h=await i.schedule(()=>v.apply(),d);const u=c();u.point!=null&&s!==u.point&&(h=n.update({point:u.point,scenePoint:u.scenePoint,context:r})),u.updatePoint!=null&&K(h,u.updatePoint)||(R(p.mapEnd,h,a,t),e.execute(p))}})}function Y(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(F.SNAPPING):G}function tt(n,t,e){return{context:new V({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:t.info!=null?t.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:t.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,originalScenePos:t.scenePoints!=null?t.scenePoints.sceneStart:null,frameTask:e}}function N(n,[t,e,i]){const s=X(n);return s.x+=t,s.y+=e,s.hasZ&&(s.z+=i),s}function nt(n,t){return n==null||t==null?null:N(n,T(t.sceneEnd,t.sceneStart))}function T(n,t){const e=n.hasZ&&t.hasZ?n.z-t.z:0;return[n.x-t.x,n.y-t.y,e]}function R(n,t,[e,i,s],o){n.x=t.x+e,n.y=t.y+i,o&&n.hasZ&&t.hasZ&&(n.z=t.z+s)}function et(n,t){if(!n.hasZ())return null;const e=t.vertices;let i=null;for(const s of e){const o=n.getZ(s.pos);if(i!=null&&o!=null&&Math.abs(o-i)>1e-6)return null;i==null&&(i=o)}return i}function I(n){return n}let f=class extends B{constructor(n){super(n),this.constrainResult=t=>t,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=A(async(t,e,i,s)=>{const o=this._frameTask;if(o==null)return;const r=await o.schedule(()=>e.snap({...t,context:i,signal:s}),s);r.valid&&await o.schedule(()=>{this.stagedPoint=r.apply(),t!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=e.update({...this._snapPoints,context:i}))},s)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(n){this._stagedPoint=this.constrainResult(n)}initialize(){var t,e;const n=this.view.type==="3d"?(e=(t=this.view)==null?void 0:t.resourceController)==null?void 0:e.scheduler:null;this._frameTask=n!=null?n.registerTask(F.SNAPPING):G}destroy(){this._abortController=C(this._abortController),this._frameTask=O(this._frameTask)}update(n,t,e){this._snapPoints=n;const{point:i,scenePoint:s}=n,o=t.update({point:i,scenePoint:s,context:e});return this.stagedPoint=o,o}async snap(n,t,e){const{point:i,scenePoint:s}=n;return this.stagedPoint=t.update({point:i,scenePoint:s,context:e}),this._snapPoints=n,this._abortController==null&&(this._abortController=new AbortController),this._snap(n,t,e,this._abortController.signal)}async snapAgainNearPreviousMapPoint(n,t){this._snapPoints!=null&&await this.snap(this._snapPoints,n,t)}abort(){this._abortController=C(this._abortController),this._snapPoints=null}};P([m({constructOnly:!0})],f.prototype,"view",void 0),P([m()],f.prototype,"stagedPoint",null),P([m()],f.prototype,"constrainResult",void 0),P([m()],f.prototype,"_stagedPoint",void 0),f=P([J("esri.views.interactive.snapping.SnappingOperation")],f);export{V as e,at as f,f as p};
