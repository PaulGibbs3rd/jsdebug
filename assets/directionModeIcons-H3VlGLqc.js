import{ew as fe,bt as k,f$ as ye,by as He,g6 as Fe,gu as J,ao as ee,qQ as We,ti as te,bp as ze,qR as ke,uN as Ge,lA as Le,g as Ue,h as Ae,uO as je,fF as qe,aP as D,aW as j,eU as ae,u as q,d1 as K,lK as ve,b as p,m as u,c as xe,gD as Be,aO as Ne,nX as _e,fP as Qe,uP as we,fO as Xe,b$ as M,j as W,bn as Ke,rb as Ye,nw as Je,jX as et,jZ as tt,nu as nt,uQ as st,fH as it,ob as le,uR as rt,uS as ot,bu as T,cE as ce,uT as B,g5 as at,g4 as lt,fo as ct,fn as pt,uU as ut,uV as ht,i1 as pe,b0 as G,uW as dt,f4 as mt,hO as be,h7 as gt,nk as ft,uX as Te,bL as yt,b_ as vt,ou as xt}from"./index-CfYeSufM.js";import{t as ue}from"./memoize-DmxaQ-k8.js";import{t as _t}from"./ReactiveSet-CYtgD1tN.js";import{a as N,i as Q}from"./dehydratedFeatureComparison-Cqp8Y6mL.js";import{P as wt,E as bt,p as Tt,b as Mt}from"./EditGeometryOperations-wQHypEHr.js";import{p as X,D as St}from"./InteractiveToolBase-XZur83Y0.js";import{g as I,Q as ne,R as Ct,U as Me,S as Pt,V as Se,W as Rt,x as $t,Z as Vt,m as Ot,X as It,H as Dt}from"./SnappingManager-uFSx-TIH.js";import{N as Zt,j as Et}from"./geodesicUtils-AyGMpq1K.js";import{T as O,j as V,R as Ce,M as Ht}from"./angularMeasurementUtils-qlhFG6W2.js";import{c as Pe}from"./SketchOptions-_RdOU_mt.js";import{p as Ft,e as he,f as Wt}from"./SnappingOperation-DKQngwsY.js";import{distance as zt,simplify as kt}from"./geometryEngine-DZQmjC3o.js";const Re="click";class Gt{constructor({consumesClicks:e,grabbableForEvent:t}){this.events=new fe,this.interactive=!0,this.selectable=!1,this.cursor=null,this.grabbable=!0,this.consumesClicks=e,this.grabbableForEvent=t}destroy(){}intersectionDistance(e,t){return 0}attach(){}detach(){}onElevationChange(){}onViewChange(){}}function fn(i,e,t,n,s,r){let o="geodesic",l=Zt(t);const a=I();return ne(i,e,n,a),a[2]=0,l&&k(a,t,a,l)||(o="euclidean",l=t),{mode:o,view:e,elevationInfo:n,hasZ:s,directionMode:r,spatialReference:i.spatialReference,measurementSR:l,origin:a}}function Lt(i,e,t){if(e==null||i==null)return;const n=We(t.measurementSR);if(n==null)return;const s=L(i,t);if(s==null)return;const r=te(e,n);return new Pt(s,r)}function Ut(i,e,t,n){if(t==null||i==null)return;const s=L(i,n);if(s==null)return;const r=O(t),o=10,l=c=>{if(c==null)return;const d=I(),g=ze(c,"degrees","geographic");return Ht(d,s,n.measurementSR,o,g,n.mode)?new $t(s,d):void 0},a=()=>{if(e!=null&&i!=null)return O(Ce(e,i))};switch(n.directionMode){case V.Absolute:return l(r);case V.Relative:{const c=a();return c==null?void 0:l(c+r)}case V.RelativeBilateral:{const c=a();return c==null?void 0:Se([l(c+r),l(c-r)])}}}function $e(i,e){const t=U(i,e);return t!=null?new Rt(t):void 0}function Ve(i,e,t){const{context:n,longitude:s,latitude:r,direction:o,distance:l,elevation:a}=t;if(s!=null||r!=null||l!=null||a!=null||o!=null){if(s!=null||r!=null){const c=O(s),d=O(r),g=U(a,n);return new Me(c,d,g)}return At(i,e,t)}}function At(i,e,{context:t,direction:n,distance:s,elevation:r}){if(e==null)return $e(r,t);const{view:o,elevationInfo:l,measurementSR:a}=t,c=ne(e,o,l);if(!a||!k(c,e.spatialReference,de,a))return;const[d,g]=de,_=s!=null?te(s,"meters"):void 0,w=O(n),f=U(r,t),y=v=>{const x=new Vt([d,g],a,_,f,v);return _==null||v==null||f==null&&t.hasZ?x:new Ot(x.closestTo(c))};if(w==null)return y(void 0);const b=()=>{if(i!=null&&e!=null)return O(Ce(i,e))};switch(t.directionMode){case V.Absolute:return y(w);case V.Relative:{const v=b();return v==null?void 0:y(v+w)}case V.RelativeBilateral:{const v=b();return v==null?void 0:Se([y(v+w),y(v-w)])}}}function jt(i){return i.context.mode==="geodesic"?Ve(null,null,i):Oe(i)}function qt(i,e,t){const{context:n,x:s,y:r,distance:o,direction:l,elevation:a}=t;return n.mode==="geodesic"?Ve(e,i,t):s!=null||r!=null?Oe(t):Bt([Lt(i,o,n),Ut(i,e,l,n),$e(a,n)])}function Oe({x:i,y:e,elevation:t,context:n}){E.x=(i==null?void 0:i.value)??0,E.y=(e==null?void 0:e.value)??0,E.spatialReference=n.spatialReference;const s=L(E,n,Xt);return new Me(i!=null&&s!=null?s[0]:void 0,e!=null&&s!=null?s[1]:void 0,U(t,n))}function Bt(i){let e;for(const t of i)t&&(e=(e==null?void 0:e.intersect(t))??t);return e}function L(i,e,t=I()){const{view:n,elevationInfo:s,measurementSR:r,origin:o,mode:l}=e;if(ne(i,n,s,t),k(t,i.spatialReference,t,r))return l!=="geodesic"&&ye(t,t,o),t}function Nt(i,e,t,n){const{view:s,measurementSR:r,spatialReference:o,origin:l,mode:a}=t;if(a==="geodesic"?He(Z,i):Fe(Z,i,l),k(Z,r,Z,o))return Ct(Z,s,e,t,n)}function U(i,e){var t;return((t=Qt(i,e))==null?void 0:t.value)??void 0}function Qt(i,{view:e,origin:t,elevationInfo:n,hasZ:s,measurementSR:r}){if(i==null||!s)return;const o=ke(r);if(o==null)return;const[l,a]=t,c=te(i,o),d=(e==null?void 0:e.type)==="3d"?Ge(e,l,a,c,r,n):c;return d!=null?Le(d,o):void 0}const de=I(),Xt=I(),Z=I(),E=J(0,0,0,ee.WGS84),Kt="crosshair",Yt="progress",me=Symbol(),ge=Symbol();let h=class extends fe.EventedMixin(Ue){constructor(e){super(e),this._createOperationCompleted=!1,this._hideDefaultCursor=!1,this._pointerDownStates=new _t,this._stagedScreenPoint=null,this._stagedPointerType=null,this._updatingHandles=new Ae,this._stagedPointerId=null,this.constraintsEnabled=!1,this.constraints=void 0,this._getPointConstraint=ue(jt),this._getPolylineOrPolygonConstraint=ue(qt),this.constraintZ=null,this.defaultZ=null,this.isDraped=!0,this.labelOptions=new Pe,this.cursor=null,this.loading=!1,this.snapToSceneEnabled=null,this.firstVertex=null,this.lastVertex=null,this.secondToLastVertex=null,e.elevationInfo==null&&(this.elevationInfo=je(!!e.hasZ))}initialize(){const{geometryType:e,view:t}=this,n=t.spatialReference,s="viewingMode"in t.state?t.state.viewingMode:qe.Local,r=e==="segment"||e==="multipoint"?"polyline":e;this.coordinateHelper=wt(this.hasZ,this.hasM,n),this._editGeometryOperations=new bt(new Tt(r,this.coordinateHelper),s),this._snappingOperation=new Ft({view:t}),this.addHandles([D(()=>({stagedPoint:this._snappingOperation.stagedPoint,constraint:this._constraint}),({stagedPoint:a,constraint:c},d)=>{const{snappingOptions:g}=this;if(g&&(g.forceDisabled=c!=null&&It(c)),d!=null&&a===d.stagedPoint&&c!==d.constraint)return this._onKeyboardBasedChange();this._processCursor(a??this._screenToMap(this._stagedScreenPoint))},{equals:(a,c)=>a.stagedPoint===c.stagedPoint&&Be(a.constraint,c.constraint)}),D(()=>this.view.viewpoint,(a,c)=>{a&&c&&Ne(a,c)&&this._onKeyboardBasedChange()})]),this._activeComponent=new Mt(n,s),this._editGeometryOperations.data.components.push(this._activeComponent);const o=this.segmentLabels;o!=null&&(o.context={view:t,editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,labelOptions:this.labelOptions},this.addHandles(D(()=>this.labelOptions.enabled,a=>{o.visible=a},j))),this.addHandles(this._editGeometryOperations.on(["vertex-add","vertex-update","vertex-remove"],a=>{var f,y,b,v;const c=a.vertices.map(x=>({componentIndex:0,vertexIndex:x.index,coordinates:this.coordinateHelper.vectorToArray(x.pos)})),d=c.map(x=>x.coordinates),g=this.coordinateHelper.vectorToDehydratedPoint((f=this._activeComponent.getFirstVertex())==null?void 0:f.pos)??null;N(g,this.firstVertex)||(this.firstVertex=g);const _=this.coordinateHelper.vectorToDehydratedPoint((y=this._activeComponent.getLastVertex())==null?void 0:y.pos)??null;N(_,this.lastVertex)||(this.lastVertex=_);const w=this.coordinateHelper.vectorToDehydratedPoint((v=(b=this._activeComponent.edges.at(-1))==null?void 0:b.leftVertex)==null?void 0:v.pos)??null;switch(N(w,this.secondToLastVertex)||(this.secondToLastVertex=w),this._processCursor(this.cursorVertex),a.type){case"vertex-add":this.emit(a.type,{...a,added:d,vertices:c});break;case"vertex-update":this.emit(a.type,{...a,updated:d,vertices:c});break;case"vertex-remove":this.emit(a.type,{...a,removed:d,vertices:c})}}));const l=this._manipulator=new Gt({consumesClicks:!1,grabbableForEvent:a=>this.drawingMode!=="click"||a.pointerType==="touch"&&this._snappingEnabled&&this._pointerDownStates.size===1});this.manipulators.add(l),l.grabbable=e!=="point"&&e!=="multipoint",this.addHandles([l.events.on("immediate-click",a=>this._onImmediateClick(a)),l.events.on("immediate-double-click",a=>this._onImmediateDoubleClick(a)),D(()=>this.drawingMode,()=>{this.removeHandles(me),this.addHandles(this._createManipulatorDragPipeline(l),me)},j),D(()=>({effectiveCursor:this.effectiveCursor}),({effectiveCursor:a})=>{l.cursor=a},j)]),Dt(this,()=>{const a=this.view.inputManager.latestPointerType??"mouse",c=this._getSnappingContext(a);if(this.snappingManager!=null){const d=this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager,c);this._updatingHandles.addPromise(ae(d))}})}destroy(){q(this.segmentLabels),q(this._snappingOperation),this._editGeometryOperations=q(this._editGeometryOperations),this._updatingHandles.destroy()}get _isDragging(){const{_stagedPointerId:e,_manipulator:t}=this;return e!=null&&this._pointerDownStates.has(e)||t.grabbing||!t.interactive}get _snappingEnabled(){return this.snappingManager!=null&&this.snappingManager.options.effectiveEnabled}get _requiresScenePoint(){const e=this._updateAndGetEffectiveDrawSurface();return this.view.type==="3d"&&this.drawSurface!==e}get canRedo(){return this._editGeometryOperations.canRedo}get canUndo(){return this._editGeometryOperations.canUndo}get committedVertices(){return this._activeComponent.vertices.map(e=>this.coordinateHelper.vectorToArray(e.pos))}get _constraint(){const{constraints:e,constraintsEnabled:t}=this;if(e&&t)switch(this.geometryType){case"point":case"multipoint":return this._getPointConstraint(e);case"polygon":case"polyline":return this._getPolylineOrPolygonConstraint(this.lastVertex,this.secondToLastVertex,e)}}set drawingMode(e){this._set("drawingMode",e??Re)}get effectiveCursor(){return this.loading?Yt:this._hideDefaultCursor?null:this.cursor||Kt}get interactive(){return this._manipulator.interactive}set interactive(e){this._manipulator.interactive=e}get isCompleted(){return this._createOperationCompleted}get numCommittedVertices(){return this._activeComponent.vertices.length}get snappingOptions(){return this.snappingManager!=null?this.snappingManager.options:null}get cursorVertex(){return this._get("cursorVertex")}get visualizationCursorVertex(){return this._stagedPointerType==="mouse"?this.cursorVertex:null}get committableVertex(){const{cursorVertex:e,lastVertex:t,firstVertex:n,geometryType:s}=this;return s==="polygon"&&Q(e,n)||Q(e,t)?null:e}get updating(){return this._updatingHandles.updating}get geometryIncludingUncommittedVertices(){const{committedVertices:e,committableVertex:t,coordinateHelper:n}=this,s=e.slice();return t!=null&&s.push(n.pointToArray(t)),s}cancel(){this.complete({aborted:!0})}commitStagedVertex(){this._snappingOperation.abort();const{committableVertex:e}=this;e!=null&&this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(e))}complete(e){var o;const t=(e==null?void 0:e.aborted)||!1;this._snappingOperation.abort(),(o=this.snappingManager)==null||o.doneSnapping();const{geometryType:n,numCommittedVertices:s}=this,r=n==="multipoint"&&s===0||n==="polyline"&&s<2||n==="polygon"&&s<3;n!=="segment"&&n!=="point"||this.commitStagedVertex(),this._createOperationCompleted=!r,(this.isCompleted||t)&&(this._stagedScreenPoint=null,this._stagedPointerId=null,this._stagedPointerType=null,this._processCursor(null),this.emit("complete",{vertices:this.committedVertices.map((l,a)=>({componentIndex:0,vertexIndex:a,coordinates:l})),aborted:t,type:"complete"}))}onInputEvent(e){switch(e.type){case"pointer-down":this._pointerDownStates.add(e.pointerId);break;case"pointer-up":this._pointerDownStates.delete(e.pointerId)}switch(e.type){case"pointer-move":return this._onPointerMove(e);case"hold":return this._onHold(e)}}redo(){this._editGeometryOperations.redo()}undo(){this.snappingManager!=null&&this.snappingManager.doneSnapping(),this._editGeometryOperations.undo()}_processCursor(e){var l,a;const t=K(this.cursorVertex),n=K(e),s=n&&(((l=this._updateAndGetEffectiveDrawSurface())==null?void 0:l.constrainZ(n))??n),r=this._snapToClosingVertex(s),o=this._applyConstraints(r);Q(t,o)||(this._set("cursorVertex",o),(a=this.segmentLabels)==null||a.set("stagedVertex",o!=null?this.coordinateHelper.pointToVector(o):null),o==null||this._stagedPointerType!=="mouse"?this.emit("cursor-remove"):this.emit("cursor-update",{updated:null,vertices:[{componentIndex:0,vertexIndex:this._activeComponent.vertices.length,coordinates:this.coordinateHelper.pointToArray(o)}],operation:"apply",type:"vertex-update"}))}_snapToClosingVertex(e){if(e==null||this._isDragging||this.geometryType!=="polygon"||this.numCommittedVertices<=2)return e;const t=this._mapToScreen(e);if(!t)return e;const n=this._activeComponent;return this._vertexWithinPointerDistance(n.vertices[0].pos,t)?this.firstVertex:this._vertexWithinPointerDistance(n.vertices.at(-1).pos,t)?this.lastVertex:e}_createManipulatorDragPipeline(e){switch(this.drawingMode){case"click":return this._createManipulatorDragPipelineClick(e);case"freehand":return this._createManipulatorDragPipelineFreehand(e);case"hybrid":return this._createManipulatorDragPipelineHybrid(e)}}_createManipulatorDragPipelineClick(e){return X(e,(t,n,s,r)=>{const o=r==="touch"&&this._snappingEnabled;if(this.isCompleted||!o)return;const{snappingStep:l,cancelSnapping:a}=Wt({predicate:()=>o,snappingManager:this.snappingManager,snappingContext:new he({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,feature:this.graphic,pointer:r,visualizer:this.snappingVisualizer,drawConstraints:this.constraints}),updatingHandles:this._updatingHandles,useZ:!this._requiresScenePoint});s=s.next(c=>(o&&this.snappingManager!=null&&this.snappingManager.doneSnapping(),c)).next(a),n.next(this._screenToMapDragEventStep()).next(c=>(c.action==="start"&&(this._processCursor(c.mapStart),(this.geometryType==="segment"||o&&!this.numCommittedVertices)&&this.commitStagedVertex()),c)).next(St(this.view,this.elevationInfo)).next(...l).next(c=>(o&&(this._processCursor(c.mapEnd),c.action==="end"&&this.commitStagedVertex()),c)).next(c=>(c.action==="end"&&(this._stagedPointerType!=="mouse"&&this._snappingOperation.abort(),this.geometryType!=="segment"&&this.geometryType!=="point"||this.complete()),c))})}_createManipulatorDragPipelineFreehand(e){return X(e,(t,n)=>{this.isCompleted||n.next(this._screenToMapDragEventStep()).next(s=>(s.action==="start"&&(this._snappingOperation.abort(),this.committableVertex==null&&this._processCursor(s.mapStart),this.geometryType==="segment"&&this.commitStagedVertex()),s)).next(s=>{switch(s.action){case"start":case"update":this._processCursor(s.mapEnd),this.geometryType!=="polygon"&&this.geometryType!=="polyline"||this.commitStagedVertex();break;case"end":this.complete()}return s})})}_createManipulatorDragPipelineHybrid(e){return X(e,(t,n)=>{this.isCompleted||n.next(this._screenToMapDragEventStep()).next(s=>(s.action==="start"&&(this._snappingOperation.abort(),this.addHandles(this._editGeometryOperations.createUndoGroup(),ge),this._processCursor(s.mapStart),this.commitStagedVertex()),s)).next(s=>{switch(s.action){case"start":case"update":this._processCursor(s.mapEnd),this.geometryType!=="polygon"&&this.geometryType!=="polyline"||this.commitStagedVertex();break;case"end":this._stagedPointerType!=="mouse"&&this._snappingOperation.abort(),this.removeHandles(ge),this.geometryType!=="segment"&&this.geometryType!=="point"||this.complete()}return s})})}get _drawAtFixedElevation(){const{constraintsEnabled:e,constraintZ:t,geometryType:n,numCommittedVertices:s}=this;return e?t!=null||n==="segment"&&s>0:(n==="segment"||n==="polygon")&&s>0}_updateAndGetEffectiveDrawSurface(){var c;const{constraintsEnabled:e,coordinateHelper:t,drawSurface:n,elevationDrawSurface:s,snapToSceneEnabled:r}=this;if(s==null)return n;if(!this.hasZ)return s.defaultZ=null,s;const o=(c=this.elevationInfo)==null?void 0:c.mode;let l=this.defaultZ,a=e||o==="absolute-height";return r!=null&&(a=r),o==="on-the-ground"&&(a=!1),this._drawAtFixedElevation&&(l=(e?this.constraintZ:null)??t.getZ(this._activeComponent.vertices[0].pos),a=!1),a?n:(s.defaultZ=l,s)}_mapToScreen(e){var t;return(t=this._updateAndGetEffectiveDrawSurface())==null?void 0:t.mapToScreen(e)}_onHold(e){this._snappingOperation.abort(),this.drawingMode==="click"&&e.pointerType==="touch"&&this._snappingEnabled&&this._processCursor(e.mapPoint),e.stopPropagation()}_onImmediateClick(e){if(!(e.pointerType==="mouse"&&e.button===2||this._manipulator.dragging))try{const{drawingMode:t,geometryType:n}=this;this._stagedPointerType=e.pointerType,this._stagedScreenPoint=e.screenPoint;const s=this._screenToMap(e.screenPoint);if(s==null||s==null||t==="freehand"&&n!=="point"&&n!=="multipoint")return;if(this._snappingEnabled&&this.cursorVertex!=null||this._processCursor(s),this.committableVertex==null)return void this.complete();this.commitStagedVertex(),e.pointerType!=="mouse"&&this._processCursor(null),(t==="freehand"&&this.geometryType!=="multipoint"||n==="point"||n==="segment"&&this.numCommittedVertices===2||n==="segment"&&t==="hybrid"&&this.numCommittedVertices===1)&&this.complete()}finally{e.stopPropagation()}}_onImmediateDoubleClick(e){this._manipulator.dragging||this.geometryType==="point"||(this.complete(),e.stopPropagation())}_onPointerMove(e){const t=ve(e.x,e.y);this._stagedScreenPoint=t,this._stagedPointerType=e.pointerType,this._stagedPointerId=e.pointerId,this._isDragging?this._snappingOperation.abort():(e.stopPropagation(),this._processCursorMovementRelativeToSurface(t,e.pointerType))}_onKeyboardBasedChange(){this._stagedPointerType==="mouse"&&this._stagedScreenPoint&&this._stagedPointerId!=null&&!this._isDragging?this._processCursorMovementRelativeToSurface(this._stagedScreenPoint,this._stagedPointerType):this._snappingOperation.abort()}_processCursorMovementRelativeToSurface(e,t){var a;const n=this._snappingOperation,s=this._screenToMap(e),r=this._requiresScenePoint?(a=this.drawSurface)==null?void 0:a.screenToMap(e):null;if(s==null)return this._hideDefaultCursor=!0,this._processCursor(null),void n.abort();this._hideDefaultCursor=!1;const o=this.snappingManager;if(o==null)return this._processCursor(s),void n.abort();const l=this._getSnappingContext(t);this._updatingHandles.addPromise(ae(n.snap({point:s,scenePoint:r},o,l)))}_applyConstraints(e){const{_constraint:t,constraints:n}=this;if(!e||!n||!t)return e;const{context:s}=n,r=L(e,s),o=r?t.closestTo(r):void 0;if(!o)return e;const l=Nt(o,e,s),a=this.view.type==="2d"||s.elevationInfo.mode!=="absolute-height";return l!=null&&a&&this.constraintZ!=null&&this.hasZ&&(l.z=this.constraintZ),l}_screenToMap(e){var t;return e?(t=this._updateAndGetEffectiveDrawSurface())==null?void 0:t.screenToMap(e):null}_screenToMapDragEventStep(){let e=null;return t=>{if(t.action==="start"&&(e=this._screenToMap(t.screenStart)),e==null)return null;const n=this._screenToMap(t.screenEnd);return n!=null?{...t,mapStart:e,mapEnd:n}:null}}_vertexWithinPointerDistance(e,t){const s=this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(e));return s!=null&&Jt(s,t,25)}_getSnappingContext(e){var n;const t=this._drawAtFixedElevation?(n=this.elevationDrawSurface)==null?void 0:n.defaultZ:null;return new he({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,pointer:e,feature:this.graphic,visualizer:this.snappingVisualizer,selfSnappingZ:t!=null?{value:t,elevationInfo:this.elevationInfo}:null,drawConstraints:this.constraints})}};function Jt(i,e,t){const n=i.x-e.x,s=i.y-e.y;return n*n+s*s<=t}p([u()],h.prototype,"_hideDefaultCursor",void 0),p([u()],h.prototype,"_stagedPointerId",void 0),p([u()],h.prototype,"_isDragging",null),p([u()],h.prototype,"_snappingOperation",void 0),p([u()],h.prototype,"_snappingEnabled",null),p([u({constructOnly:!0})],h.prototype,"graphic",void 0),p([u()],h.prototype,"constraintsEnabled",void 0),p([u()],h.prototype,"constraints",void 0),p([u()],h.prototype,"_constraint",null),p([u()],h.prototype,"constraintZ",void 0),p([u()],h.prototype,"defaultZ",void 0),p([u()],h.prototype,"isDraped",void 0),p([u({value:Re})],h.prototype,"drawingMode",null),p([u({constructOnly:!0})],h.prototype,"elevationDrawSurface",void 0),p([u({constructOnly:!0})],h.prototype,"elevationInfo",void 0),p([u({constructOnly:!0,type:Pe})],h.prototype,"labelOptions",void 0),p([u({constructOnly:!0})],h.prototype,"geometryType",void 0),p([u({constructOnly:!0})],h.prototype,"hasM",void 0),p([u({constructOnly:!0})],h.prototype,"hasZ",void 0),p([u()],h.prototype,"cursor",void 0),p([u()],h.prototype,"effectiveCursor",null),p([u()],h.prototype,"loading",void 0),p([u({constructOnly:!0})],h.prototype,"manipulators",void 0),p([u({constructOnly:!0})],h.prototype,"drawSurface",void 0),p([u({constructOnly:!0})],h.prototype,"segmentLabels",void 0),p([u({constructOnly:!0})],h.prototype,"snappingManager",void 0),p([u({constructOnly:!0})],h.prototype,"snappingVisualizer",void 0),p([u()],h.prototype,"snapToSceneEnabled",void 0),p([u({readOnly:!0})],h.prototype,"cursorVertex",null),p([u({readOnly:!0})],h.prototype,"visualizationCursorVertex",null),p([u()],h.prototype,"committableVertex",null),p([u()],h.prototype,"firstVertex",void 0),p([u()],h.prototype,"lastVertex",void 0),p([u()],h.prototype,"secondToLastVertex",void 0),p([u()],h.prototype,"updating",null),p([u({constructOnly:!0})],h.prototype,"view",void 0),h=p([xe("esri.views.draw.DrawOperation")],h);class vn{constructor(e,t,n,s=null){this._elevationInfo=e,this.defaultZ=t,this._view=n,this._excludeGraphics=s}screenToMap(e){const{defaultZ:t,_view:n}=this,s=n.sceneIntersectionHelper.intersectElevationFromScreen(Qe(e.x,e.y),this._elevationInfo,t??0,this._excludeGraphics);return t==null&&s!=null&&(s.z=void 0),s}mapToScreen(e){const t=J(e.x,e.y,we(this._view,e,this._elevationInfo),e.spatialReference);return this._view.toScreen(t)}constrainZ(e){const{defaultZ:t}=this;return t!=null&&e.z!==t&&((e=_e(e)).z=t),e}}class xn{constructor(e,t,n=[]){this.view=e,this.elevationInfo=t,this.exclude=n}screenToMap(e){const t=this.view.toMap(e,{exclude:this.exclude,excludeLabels:!0});return t!=null&&(t.z=Xe(t,this.view,this.elevationInfo)),t}mapToScreen(e){let t=e;return this.elevationInfo!=null&&(t=J(e.x,e.y,we(this.view,e,this.elevationInfo),e.spatialReference)),this.view.toScreen(t)}constrainZ(e){return e}}class _n{constructor(e,t=!1,n=0){this.view=e,this.hasZ=t,this.defaultZ=n,this.mapToScreen=s=>e.toScreen(s),this.screenToMap=t?s=>{const r=e.toMap(s);return r.z=n,r}:s=>e.toMap(s)}constrainZ(e){const{defaultZ:t}=this;return this.hasZ&&e.z!==t&&((e=_e(e)).z=t),e}}class se{screenToMap(e){const{x:t,y:n}=e;return new M({x:t,y:n,spatialReference:se.spatialReference})}mapToScreen(e){return ve(e.x,e.y)}constrainZ(e){return e}}se.spatialReference=new ee;var Y;let C=Y=class extends W{constructor(i){super(i),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const i=this.center,e=this.numberOfPoints;if(this.hasZ=(i==null?void 0:i.hasZ)??!1,this.rings.length!==0||!i)return;const t=Ke(this.radius,this.radiusUnit,"meters"),n=i.spatialReference;let s,r="geographic";if(n.isWebMercator?r="webMercator":((n.wkid&&Ye[n.wkid])!=null||(n.wkt2||n.wkt)&&Je(n.wkt2||n.wkt))&&(r="projected"),this.geodesic){let o;switch(r){case"webMercator":o=et(i);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":o=i}s=this._createGeodesicCircle(o,t,e),r==="webMercator"&&(s=tt(s))}else{let o;r==="webMercator"||r==="projected"?o=t/nt(i.spatialReference):r==="geographic"&&(o=st(t,"meters",it(i.spatialReference).radius)),s=this._createPlanarCircle(i,o,e)}this.spatialReference=s.spatialReference,this.addRing(s.rings[0])}clone(){const{center:i,numberOfPoints:e,radius:t,radiusUnit:n,geodesic:s}=this;return new Y({center:i==null?void 0:i.clone(),numberOfPoints:e,radius:t,radiusUnit:n,geodesic:s})}_createGeodesicCircle(i,e,t){const n=[],s=[i.x,i.y];for(let r=0;r<360;r+=360/t){const o=this.hasZ?[0,0,i.z??0]:[0,0];Et(o,s,r,e,ee.WGS84),n.push(o)}return n.push(n[0]),new W({rings:[n]})}_createPlanarCircle(i,e,t){const n=[],s=2*Math.PI/t;for(let r=0;r<t;++r){const o=s*r,l=[i.x+Math.cos(-o)*e,i.y+Math.sin(-o)*e];this.hasZ&&l.push(i.z??0),n.push(l)}return n.push(n[0]),new W({spatialReference:i.spatialReference,rings:[n]})}};p([u({type:M})],C.prototype,"center",void 0),p([u()],C.prototype,"geodesic",void 0),p([u()],C.prototype,"numberOfPoints",void 0),p([u()],C.prototype,"radius",void 0),p([u()],C.prototype,"radiusUnit",void 0),C=Y=p([xe("esri.geometry.Circle")],C);const en=C;function z(i,e,t=null){return t!=null?[i,e,t]:[i,e]}function m(i,e,t=null){return t!=null?{x:i,y:e,z:t}:{x:i,y:e}}let Ie=class{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(t=>this.mapToLocal(t)).filter(G)}get doUnnormalization(){return!1}};class tn extends Ie{constructor(e,t,n=null){super(t),this._defaultZ=n,this.transform=le(),this.transformInv=le(),this.transform=rt(e),ot(this.transformInv,this.transform)}makeMapPoint(e,t){return z(e,t,this._defaultZ)}mapToLocal(e){return m(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return z(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}}let nn=class extends Ie{constructor(e,t){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=T(),this.tangentFrameUpWS=T(),this.tangentFrameRightWS=T(),this.tangentFrameForwardWS=T(),this.localFrameRightWS=T(),this.localFrameUpWS=T(),this.worldToLocalTransform=ce(),this.localToWorldTransform=ce(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=t,this.defaultZ=t.hasZ?t.z:null;const n=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,B.X,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,B.Y,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,B.Z,this.tangentFrameForwardWS);const s=T();at(s,this.tangentFrameForwardWS,lt(n,this.tangentFrameForwardWS)),ye(this.localFrameRightWS,n,s),ct(this.localFrameRightWS,this.localFrameRightWS),pt(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),ut(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),ht(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,t){return z(e,t,this.defaultZ)}mapToLocal(e){const t=T();this.view.renderCoordsHelper.toRenderCoords(new M({x:e[0],y:e[1],spatialReference:this.spatialReference}),t),pe(t,t,this.worldToLocalTransform);const n=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return n!=null?m(n.x/this.scale,n.y/this.scale):null}localToMap(e){const t=T();this.view.renderCoordsHelper.toRenderCoords(new M({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),t),pe(t,t,this.localToWorldTransform);const n=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return n!=null?z(n.x,n.y,this.defaultZ):null}};function Tn(i,e){if(i.type==="2d")return new tn(i.state.transform,i.spatialReference,e.length>2?e[2]:null);if(i.type==="3d"){const t=e.length>2?new M({x:e[0],y:e[1],z:e[2],spatialReference:i.spatialReference}):new M({x:e[0],y:e[1],spatialReference:i.spatialReference});return new nn(i,t)}return null}function P(i,e){const t=new M({x:i[0],y:i[1],spatialReference:e});return i.length>2&&(t.z=i[2]),t}function Mn(i,e){return new vt({points:i,spatialReference:e})}function Sn(i,e,t){const n=new yt({paths:i,spatialReference:e});return t&&Te(n),n}function A(i,e,t,n=!0){const s=K(i);s.forEach(o=>{const l=o[0],a=o[o.length-1];gt(l,a)&&o.length!==1||o.push(o[0])});let r=new W({rings:s,spatialReference:e});return r.rings.forEach(o=>{ft(o)||o.reverse()}),t&&Te(r),n&&r.isSelfIntersecting&&be(e)&&(r=kt(r)),r}function Cn(i,e,t){const n=e.mapToLocalMultiple(i),s=[],r={x:n[0].x,y:n[0].y},o={x:n[1].x,y:n[1].y},l=Math.round(o.x-r.x),a=Math.round(o.y-r.y),c=Math.max(Math.abs(l),Math.abs(a));if(t){const d={x:r.x+c,y:r.y+c},g={x:r.x-c,y:r.y-c};s.push(m(d.x,g.y),m(g.x,g.y),m(g.x,d.y),m(d.x,d.y))}else{const d={x:l>0?r.x+c:r.x-c,y:a>0?r.y+c:r.y-c};s.push(m(r.x,r.y),m(d.x,r.y),m(d.x,d.y),m(r.x,d.y))}return De(A([s.map(d=>e.localToMap(d)).filter(G)],e.spatialReference,e.doUnnormalization,!0),s,e)}function Pn(i,e,t){let n=e.mapToLocalMultiple(i);if(n.length===1){const a=n[0];n=[m(a.x-48,a.y+48),m(a.x+48,a.y-48),m(a.x+48,a.y-48),m(a.x-48,a.y+48)]}const s=[],r={x:n[0].x,y:n[0].y},o={x:n[1].x,y:n[1].y};if(t){const l=Math.round(o.x-r.x),a=Math.round(o.y-r.y);s.push(m(r.x-l,r.y-a),m(o.x,r.y-a),m(o.x,o.y),m(r.x-l,o.y))}else s.push(m(r.x,r.y),m(o.x,r.y),m(o.x,o.y),m(r.x,o.y));return De(A([s.map(l=>e.localToMap(l)).filter(G)],e.spatialReference,e.doUnnormalization,!0),s,e)}function De(i,e,t){const n=H(e[3],e[2],t),s=H(e[1],e[2],t),r=H(e[0],e[1],t),o=H(e[0],e[3],t);return{geometry:i,midpoints:n!=null&&s!=null&&r!=null&&o!=null?{top:n,right:s,bottom:r,left:o}:null}}function H(i,e,t){R[0]=i.x,R[1]=i.y,R[2]=0,$[0]=e.x,$[1]=e.y,$[2]=0,xt(R,R,$,.5),F.x=R[0],F.y=$[1],F.z=$[2];const n=t.localToMap(F);return n!=null?P(n,t.spatialReference):null}const F=m(0,0,0),R=T(),$=T();function Rn(i,e,t,n){const s=e.mapToLocalMultiple(i);let r=null,o=null;if(t)r=s[0],o=s[1];else{const f=s[0],y=s[1],b=Math.round(y.x-f.x),v=Math.round(y.y-f.y),x=Math.max(Math.abs(b),Math.abs(v));r=m(b>0?f.x+x/2:f.x-x/2,v>0?f.y+x/2:f.y-x/2),o=m(Math.abs(b)>Math.abs(v)?r.x-x/2:r.x,Math.abs(b)>Math.abs(v)?r.y:r.y-x/2)}const l=e.localToMap(r),a=e.localToMap(o);if(l==null||a==null)return null;e.doUnnormalization&&dt([[l,a]],e.spatialReference);const c=P(l,e.spatialReference),d=P(a,e.spatialReference),g=mt(e.spatialReference);let _=0;if(be(e.spatialReference))_=g*zt(c,d,null);else{const f=r.x-o.x,y=r.y-o.y;_=g*Math.sqrt(f*f+y*y)*(n||1)}const w=new en({center:c,radius:_,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:A(w.rings,w.spatialReference,!1),center:c,edge:d}}function $n(i,e,t){const n=e.mapToLocalMultiple(i),s=n[0],r=n[1],o=Math.round(r.x-s.x),l=Math.round(r.y-s.y),a=m(t?s.x:s.x+o/2,t?s.y:s.y+l/2),c=t?o:o/2,d=t?l:l/2,g=60,_=[],w=2*Math.PI/g;function f(S){const Ze=Math.cos(S),Ee=Math.sin(S);return m(c*Ze+a.x,d*Ee+a.y)}for(let S=0;S<g;S++)_.push(f(S*w));_.push(_[0]);const{spatialReference:y,doUnnormalization:b}=e,v=A([_.map(S=>e.localToMap(S)).filter(G)],y,b,!1),x=e.localToMap(f(Math.PI/2)),ie=e.localToMap(f(0)),re=e.localToMap(f(-Math.PI/2)),oe=e.localToMap(f(Math.PI));return{geometry:v,midpoints:x!=null&&ie!=null&&re!=null&&oe!=null?{top:P(x,y),right:P(ie,y),bottom:P(re,y),left:P(oe,y)}:null}}const Vn={absolute:"absolute-direction",relative:"relative-direction"};export{Tn as F,Rn as L,Sn as R,Cn as T,tn as W,fn as Z,h as a,Pn as b,vn as c,Mn as d,Vn as e,_n as h,A as j,xn as l,se as u,$n as v};
