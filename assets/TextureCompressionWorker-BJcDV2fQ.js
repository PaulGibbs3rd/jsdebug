import{_ as g,gW as D,o_ as d,o$ as A}from"./index-CzvLtnX1.js";function S(){return C??=(async()=>{const e=await g(()=>import("./basis_encoder-sWYVw54x.js"),[]),n=await e.default({locateFile:t=>D(`esri/libs/basisu/${t}`)});return n.initializeBasis(),n})(),C}let C;function R(){return y??=(async()=>await(await g(()=>import("./dxt_encoder-CMbor95M.js"),[])).default({locateFile:n=>D(`esri/libs/dxtEncoder/${n}`)}))(),y}let y,X,b,c=null,_=null;class w{constructor(n,t){this.internalFormat=n,this.compressedTexture=t}}async function Q(e){const n=M(e.data,e.flipped);if(e.hasS3TC){_||await B();const t=new Uint8Array(n.length);_?.encode(new Uint8Array(n),e.width,e.height,t);const a=W(t,!0),i=[t.buffer];return{result:new w(a?.internalFormat??null,a?.textureData??null),transferList:i}}if(e.hasETC){c||await x();const t=await F(n,e.width,e.height,e.hasMipmap),a=t?await G(t):null,i=a?.compressedTexture?.levels.map(o=>o.buffer)||[];return{result:new w(a?.internalFormat??null,a?.compressedTexture??null),transferList:i}}return{result:new w(null,null)}}async function x(){c||(c=await(X??=S()))}async function B(){_||(_=await(b??=R()))}async function F(e,n,t,a,i=255,o=0,s=!1,l=!1){if(!c)return null;const r=new c.BasisEncoder;r.setPerceptual(!l),r.setCheckForAlpha(!0),r.setForceAlpha(!1),r.setRenormalize(l),r.setMipGen(a),r.setMipSRGB(!l),r.setCreateKTX2File(!0),r.setKTX2SRGBTransferFunc(!l),r.setQualityLevel(i),r.setCompressionLevel(o);const h=new Uint8Array(e.byteLength);r.setSliceSourceImage(0,new Uint8Array(e),n,t,s);const T=r.encode(h),u=new Uint8Array(h.buffer,0,T),f=new c.KTX2File(new Uint8Array(u));return f.isValid()?(r.delete(),u):(f.close(),f.delete(),r.delete(),null)}async function G(e){if(!c)return new w(null,null);const n=new c.KTX2File(new Uint8Array(e));n.startTranscoding();const[t,a]=n.getHasAlpha()?[A.ETC2_RGBA,d.COMPRESSED_RGBA8_ETC2_EAC]:[A.ETC1_RGB,d.COMPRESSED_RGB8_ETC2],i=n.getLevels(),o=[];for(let s=0;s<i;s++)o.push(new Uint8Array(n.getImageTranscodedSizeInBytes(s,0,0,t))),n.transcodeImage(o[s],s,0,0,t,0,-1,-1);return n.close(),n.delete(),{internalFormat:a,compressedTexture:{type:"compressed",levels:o}}}function M(e,n=!1){const t=new OffscreenCanvas(e.width,e.height),a=t.getContext("2d");return n&&a.scale(1,-1),a.drawImage(e,0,n?-e.height:0),a.getImageData(0,0,t.width,t.height).data}const O=31,v=1,I=2,P=3,U=4,L=7,K=21,$=131072;function m(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}const k=m("DXT1"),z=m("DXT3"),V=m("DXT5");function W(e,n){const t=new Int32Array(e.buffer,e.byteOffset,O);let a,i;switch(t[K]){case k:a=8,i=d.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case z:a=16,i=d.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case V:a=16,i=d.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;default:return null}let o=1,s=t[U],l=t[P];(3&s||3&l)&&(s=s+3&-4,l=l+3&-4);const r=s,h=l;let T,u;t[I]&$&&n!==!1&&(o=Math.max(1,t[L]));let f=e.byteOffset+t[v]+4;const p=[];for(let E=0;E<o;++E)u=(s+3>>2)*(l+3>>2)*a,T=new Uint8Array(e.buffer,f,u),p.push(T),f+=u,s=Math.max(1,s>>1),l=Math.max(1,l>>1);return{textureData:{type:"compressed",levels:p},internalFormat:i,width:r,height:h}}export{w as TextureCompressionWorkerOutput,Q as compress,F as compressRGBADataToKTX2,G as createTextureDataKTX2,x as initializeBasisEncoder,B as initializeDXTEncoder};
