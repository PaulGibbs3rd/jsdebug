import{ie as h,ig as L,H as y,ba as S,aq as T,bc as v}from"./index-CzvLtnX1.js";import{t as F,a as M}from"./fetchService-Cxb-2UbM.js";import{c as $,n as P,l as f,a as G,o as x,u as g,e as I,i as D,t as m}from"./loadUtils-CyhMMpqf.js";import"./associatedFeatureServiceUtils-C-p16ht_.js";async function V(t,r){const a=t.instance.portalItem;if(a?.id)return await a.load(r),C(t),t.validateItem&&t.validateItem(a),k(t,r)}function C(t){const r=t.instance.portalItem;if(!r?.type||!t.supportedTypes.includes(r.type))throw new y("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:r?.type,expectedType:t.supportedTypes.join(", ")})}async function k(t,r){const a=t.instance,e=a.portalItem;if(!e)return;const{url:o,title:n}=e,l=h(e,"portal-item");if(a.type==="group")return j(a,l,t);o&&a.type!=="media"&&a.read({url:o},l);const u=new I,s=await b(t,u,r);return s&&a.read(s,l),a.resourceReferences={portalItem:e,paths:l.readResourcePaths??[]},a.type!=="subtype-group"&&a.read({title:n},l),L(a,l)}async function j(t,r,a){const e=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:o,type:n}=e;if(n==="Group Layer"){if(!S(e,"Map"))throw new y("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return A(t,a)}return t.read({title:o},r),E(t,a)}async function A(t,r){const a=t.portalItem,e=await a.fetchData("json");if(!e)return;if(!r.populateGroupLayer)throw new y("portal:missing-populate-group-layer","Missing populate group layer");const o=h(a,"web-map");t.read(e,o),await r.populateGroupLayer(t,e,{context:o}),t.resourceReferences={portalItem:a,paths:o.readResourcePaths??[]}}async function E(t,r){let a;const{portalItem:e}=t;if(!e)return;const o=e.type,n=r.layerModuleTypeMap;if(!n)throw new y("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(o){case"Feature Service":case"Feature Collection":a=n.FeatureLayer;break;case"Stream Service":a=n.StreamLayer;break;case"Scene Service":a=n.SceneLayer;break;default:throw new y("portal:unsupported-item-type-as-group",`The item type '${o}' is not supported as a 'IGroupLayer'`)}const l=new I;let[u,s]=await Promise.all([a(),b(r,l)]),i=()=>u;if(o==="Feature Service"){const c=f(s)?.customParameters;s=e.url?await G(s,e.url,l):{},i=await z(s,n)||i;const p=await H(e.url,{customParameters:c,loadContext:l});return await d(t,i,i,s,n,p)}return o==="Scene Service"&&e.url&&(s=await x(e,s,l)),g(s)>0?await d(t,i,null,s,n):await O(t,i,n)}async function O(t,r,a){const{portalItem:e}=t;if(!e?.url)return;const o=await M(e.url);o&&d(t,r,null,{layers:o.layers?.map(m),tables:o.tables?.map(m)},a)}async function d(t,r,a,e,o,n){let l=e.layers||[];const u=e.tables||[];if(t.portalItem?.type==="Feature Collection"?(l.forEach((s,i)=>{s.id=i,s?.layerDefinition?.type==="Table"&&u.push(s)}),l=l.filter(s=>s?.layerDefinition?.type!=="Table")):(l.reverse(),u.reverse()),l.forEach(s=>{const i=n?.(s);if(i||!n){const c=w(t,r(s),e,s,i);t.add(c)}}),u.length){const s=a?null:await o.FeatureLayer();u.forEach(i=>{const c=n?.(i);if(c||!n){const p=w(t,a?a(i):s,e,i,c);t.tables.add(p)}})}}function w(t,r,a,e,o){const n=t.portalItem,l={portalItem:n.clone(),layerId:e.id};e.url!=null&&(l.url=e.url);const u=new r(l);if("sourceJSON"in u&&(u.sourceJSON=o),u.type!=="subtype-group"&&u.type!=="catalog"&&(u.sublayerTitleMode="service-name"),n.type==="Feature Collection"){const s={origin:"portal-item",portal:n.portal||v.getDefault()};u.read(e,s);const i=a.showLegend;i!=null&&u.read({showLegend:i},s)}return u}async function b(t,r,a){if(t.supportsData===!1)return;const e=t.instance,o=e.portalItem;if(!o)return;let n=null;try{n=await o.fetchData("json",a)}catch{}if(N(e)){let l=null;const u=await R(o,n,r);if((n?.layers||n?.tables)&&u>0){if(e.layerId==null){const s=$(e.type),i=s?.length?P(n,s)[0]:f(n);i&&(e.layerId=i.id)}l=J(n,e),l?.layerType==="OrientedImageryLayer"&&e.type==="oriented-imagery"&&e.supportedSourceTypes.add("Feature Layer"),l&&n.showLegend!=null&&(l.showLegend=n.showLegend)}return u>1&&"sublayerTitleMode"in e&&e.sublayerTitleMode!=="service-name"&&(e.sublayerTitleMode="item-title-and-service-name"),l}return n}async function R(t,r,a){if(r?.layers&&r?.tables)return g(r);const e=T(t.url);if(!e)return 1;const o=await a.fetchServiceMetadata(e.url.path,{customParameters:f(r)?.customParameters}).catch(()=>null);return(r?.layers?.length??o?.layers?.length??0)+(r?.tables?.length??o?.tables?.length??0)}function J(t,r){const{layerId:a}=r,e=t.layers?.find(o=>o.id===a)||t.tables?.find(o=>o.id===a);return e&&q(e,r)?e:null}function N(t){return t.type!=="stream"&&"layerId"in t}function q(t,r){const a="layerType"in t&&t.layerType,{type:e}=r;return!(e==="feature"&&a&&t.layerType!=="ArcGISFeatureLayer"||e==="catalog"&&!a||e==="oriented-imagery"&&!a||e==="subtype-group"&&!a)}async function H(t,r){const{layersJSON:a}=await F(t,r);if(!a)return null;const e=[...a.layers,...a.tables];return o=>e.find(n=>n.id===o.id)}async function z(t,r){const{layers:a,tables:e}=t,o=[...a??[],...e??[]];if(!o.length)return;const n=new Set,l=[];for(const{layerType:i}of o){const c=i??"ArcGISFeatureLayer";if(n.has(c))continue;n.add(c);const p=r[D(c)];l.push(p())}const u=await Promise.all(l),s=new Map;return Array.from(n).forEach((i,c)=>{s.set(i,u[c])}),({layerType:i})=>{const c=i??"ArcGISFeatureLayer";return s.get(c)}}export{V as load};
