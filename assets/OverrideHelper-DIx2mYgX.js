import{c_ as y,c$ as v,d0 as b,d1 as u,d2 as M,d3 as C,d4 as I,d5 as x,d6 as k,d7 as O,aD as S}from"./index-CzvLtnX1.js";import h from"./callExpressionWithFeature-BqIGys1L.js";const N=f=>{if(!f)return[0,0,0,0];const{r:e,g:r,b:s,a:i}=f;return[e,r,s,255*i]};class o{static findApplicableOverrides(e,r,s){if(e&&r){if(e.primitiveName){let i=!1;for(const t of s)if(t.primitiveName===e.primitiveName){i=!0;break}if(!i)for(const t of r)t.primitiveName===e.primitiveName&&s.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)o.findApplicableOverrides(i,r,s);if(e.symbolLayers)for(const i of e.symbolLayers)o.findApplicableOverrides(i,r,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const i of e.effects)o.findApplicableOverrides(i,r,s);if(e.markerPlacement&&o.findApplicableOverrides(e.markerPlacement,r,s),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const i of e.markerGraphics)o.findApplicableOverrides(i,r,s),o.findApplicableOverrides(i.symbol,r,s)}else e.type==="CIMCharacterMarker"?o.findApplicableOverrides(e.symbol,r,s):e.type==="CIMHatchFill"?o.findApplicableOverrides(e.lineSymbol,r,s):e.type==="CIMPictureMarker"&&o.findApplicableOverrides(e.animatedSymbolProperties,r,s)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&y(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const s=v(e),i=e.primitiveName,t=[];for(const c of r)c.primitiveName===i&&t.push(v(c));return{type:"cim-effect-param",effect:s,overrides:b(t)}}static async resolveSymbolOverrides(e,r,s,i,t,c,a){if(!e?.symbol)return null;let{symbol:n,primitiveOverrides:l}=e;const m=!!l;if(!m&&!i)return n;n=u(n),l=u(l);let d=!0;if(r||(r={attributes:{}},d=!1),m){if(d||(l=l.filter(p=>!p.valueExpressionInfo?.expression.includes("$feature"))),a||(l=l.filter(p=>!p.valueExpressionInfo?.expression.includes("$view"))),l.length>0){const p={spatialReference:s,fields:M(r.attributes),geometryType:t};await o.createRenderExpressions(l,p),o.evaluateOverrides(l,r,t??"esriGeometryPoint",c,a)}o.applyOverrides(n,l)}return i&&o.applyDictionaryTextOverrides(n,r,i,null),n}static async createRenderExpressions(e,r){const s=[];for(const i of e){const t=i.valueExpressionInfo;if(!t||o._expressionToRenderExpression.has(t.expression))continue;const c=C(t.expression,r.spatialReference,r.fields);s.push(c),c.then(a=>o._expressionToRenderExpression.set(t.expression,a))}s.length>0&&await Promise.all(s)}static evaluateOverrides(e,r,s,i,t){const c={$view:{scale:t?.scale}};for(const a of e){a.value&&typeof a.value=="object"&&I(a.value)&&(a.propertyName==="Color"||a.propertyName==="StrokeColor")&&(a.value=N(a.value));const n=a.valueExpressionInfo;if(!n)continue;const l=o._expressionToRenderExpression.get(n.expression);l&&(a.value=h(l,r,c,s,i))}}static applyDictionaryTextOverrides(e,r,s,i,t="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const c=e.symbolLayers;if(!c)return;for(const a of c)a&&a.type==="CIMVectorMarker"&&o.applyDictionaryTextOverrides(a,r,s,i,e.type==="CIMTextSymbol"?e.textCase:t)}break;case"CIMVectorMarker":{const c=e.markerGraphics;if(!c)return;for(const a of c)a&&o.applyDictionaryTextOverrides(a,r,s,i)}break;case"CIMMarkerGraphic":{const c=e.textString;if(c&&c.includes("[")){const a=x(c,s);e.textString=k(r,a,i,t)}}}}static applyOverrides(e,r,s,i){if(e.primitiveName){for(const t of r)if(t.primitiveName===e.primitiveName){const c=O(t.propertyName);if(i&&i.push({cim:e,nocapPropertyName:c,value:e[c]}),s){let a=!1;for(const n of s)n.primitiveName===e.primitiveName&&(a=!0);a||s.push(t)}t.value!=null&&(e[c]=t.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)o.applyOverrides(t,r,s,i);if(e.symbolLayers)for(const t of e.symbolLayers)o.applyOverrides(t,r,s,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const t of e.effects)o.applyOverrides(t,r,s,i);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const t of e.markerGraphics)o.applyOverrides(t,r,s,i),o.applyOverrides(t.symbol,r,s,i)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const s of e)s.value!==void 0&&(r+=`${s.primitiveName}${s.propertyName}${JSON.stringify(s.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(s=>Number(s));if(e==="Color"){const s=new S(r).toRgba();return s[3]*=255,s}return r}}o._expressionToRenderExpression=new Map;export{o as OverrideHelper};
