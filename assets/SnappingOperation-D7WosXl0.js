import{nq as L,aP as q,fe as C,dm as O,n$ as G,fs as F,nX as D,eU as X,ch as A,g as B,b as P,m,c as J}from"./index-CzvLtnX1.js";import{a as K}from"./dehydratedFeatureComparison-BBO76xQi.js";import{w as Q}from"./InteractiveToolBase-CXcuwHxr.js";class V{constructor(t){this.vertexHandle=null,this.excludeFeature=null,this.visualizer=null,this.selfSnappingZ=null,this.drawConstraints=null,this.editGeometryOperations=t.editGeometryOperations,this.elevationInfo=t.elevationInfo,this.pointer=t.pointer,this.vertexHandle=t.vertexHandle,this.excludeFeature=t.excludeFeature,this.feature=t.feature,this.visualizer=t.visualizer,this.selfSnappingZ=t.selfSnappingZ,this.drawConstraints=t.drawConstraints}get coordinateHelper(){return this.editGeometryOperations.data.coordinateHelper}get spatialReference(){return this.coordinateHelper.spatialReference}}function at({predicate:n=()=>!0,snappingManager:t,snappingContext:s,updatingHandles:i,useZ:e=!0}){const o=new Q;if(t==null)return{snappingStep:[I,o],cancelSnapping:I};let r,p=null,a=null,c=null;const d=()=>{p=C(p),t.doneSnapping(),a?.frameTask.remove(),a=null,r=O(r),c=null},v=W(t,e,o);let h=null,u=null,b=null;return{snappingStep:[l=>{if(!n(l))return l;const{action:_}=l;if(_==="start"){const{info:x}=l,y=Y(t.view);if(a=tt(s,l,y),a.context.selfSnappingZ=null,!e&&x!=null){const g=et(s.coordinateHelper,x.handle.component);g!=null&&(a.context.selfSnappingZ={value:g,elevationInfo:s.elevationInfo??L})}}if(a!=null){const{context:x,originalScenePos:y,originalPos:g}=a,{mapEnd:k,mapStart:Z,scenePoints:U}=l,S=N(g,T(k,Z)),z=T(Z,g),$={...l,action:"update"},E=a.context,w=nt(y,U),H=t.update({point:S,scenePoint:w,context:x});if(b=H,R(k,H,z,e),h=S,u=w,_!=="end"){const{frameTask:M}=a;p==null&&(p=new AbortController),c=j=>{i.addPromise(X(v({frameTask:M,event:$,context:E,point:S,scenePoint:w,delta:z,getLastState:()=>({point:h,scenePoint:u,updatePoint:j.forceUpdate?null:b})},p.signal)))},c({forceUpdate:!1}),r==null&&(r=q(()=>t.options.effectiveEnabled,()=>c?.({forceUpdate:!0})))}}return _==="end"&&d(),l},o],cancelSnapping:l=>(d(),l)}}function W(n,t,s){return A(async({frameTask:i,point:e,scenePoint:o,context:r,event:p,delta:a,getLastState:c},d)=>{const v=await i.schedule(()=>n.snap({point:e,scenePoint:o,context:r,signal:d}),d);if(v.valid){let h=await i.schedule(()=>v.apply(),d);const u=c();u.point!=null&&e!==u.point&&(h=n.update({point:u.point,scenePoint:u.scenePoint,context:r})),u.updatePoint!=null&&K(h,u.updatePoint)||(R(p.mapEnd,h,a,t),s.execute(p))}})}function Y(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(F.SNAPPING):G}function tt(n,t,s){return{context:new V({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:t.info!=null?t.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:t.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,originalScenePos:t.scenePoints!=null?t.scenePoints.sceneStart:null,frameTask:s}}function N(n,[t,s,i]){const e=D(n);return e.x+=t,e.y+=s,e.hasZ&&(e.z+=i),e}function nt(n,t){return n==null||t==null?null:N(n,T(t.sceneEnd,t.sceneStart))}function T(n,t){const s=n.hasZ&&t.hasZ?n.z-t.z:0;return[n.x-t.x,n.y-t.y,s]}function R(n,t,[s,i,e],o){n.x=t.x+s,n.y=t.y+i,o&&n.hasZ&&t.hasZ&&(n.z=t.z+e)}function et(n,t){if(!n.hasZ())return null;const s=t.vertices;let i=null;for(const e of s){const o=n.getZ(e.pos);if(i!=null&&o!=null&&Math.abs(o-i)>1e-6)return null;i==null&&(i=o)}return i}function I(n){return n}let f=class extends B{constructor(n){super(n),this.constrainResult=t=>t,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=A(async(t,s,i,e)=>{const o=this._frameTask;if(o==null)return;const r=await o.schedule(()=>s.snap({...t,context:i,signal:e}),e);r.valid&&await o.schedule(()=>{this.stagedPoint=r.apply(),t!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=s.update({...this._snapPoints,context:i}))},e)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(n){this._stagedPoint=this.constrainResult(n)}initialize(){const n=this.view.type==="3d"?this.view?.resourceController?.scheduler:null;this._frameTask=n!=null?n.registerTask(F.SNAPPING):G}destroy(){this._abortController=C(this._abortController),this._frameTask=O(this._frameTask)}update(n,t,s){this._snapPoints=n;const{point:i,scenePoint:e}=n,o=t.update({point:i,scenePoint:e,context:s});return this.stagedPoint=o,o}async snap(n,t,s){const{point:i,scenePoint:e}=n;return this.stagedPoint=t.update({point:i,scenePoint:e,context:s}),this._snapPoints=n,this._abortController==null&&(this._abortController=new AbortController),this._snap(n,t,s,this._abortController.signal)}async snapAgainNearPreviousMapPoint(n,t){this._snapPoints!=null&&await this.snap(this._snapPoints,n,t)}abort(){this._abortController=C(this._abortController),this._snapPoints=null}};P([m({constructOnly:!0})],f.prototype,"view",void 0),P([m()],f.prototype,"stagedPoint",null),P([m()],f.prototype,"constrainResult",void 0),P([m()],f.prototype,"_stagedPoint",void 0),f=P([J("esri.views.interactive.snapping.SnappingOperation")],f);export{V as e,at as f,f as p};
