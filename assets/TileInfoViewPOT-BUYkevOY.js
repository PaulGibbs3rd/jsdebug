import{fv as N,dS as j,fw as G,w as K,K as Y,fe as J,g_ as B,jD as X,ry as Z,J as Q,s6 as z,gP as S,ak as tt,lE as W,s4 as b,lp as D,E as p,dx as m,o as A,t$ as et,c4 as V,ra as st,s2 as F,o3 as it,o4 as rt,o7 as at,o5 as nt,cZ as C,gL as ht,av as ot}from"./index-CzvLtnX1.js";import{t as x}from"./Rect-CUzevAry.js";import{a as lt}from"./pbf-DU6DDbsT.js";import{u as ct}from"./rasterizingUtils-C1i-aeFk.js";class P{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new x(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new x;let e=null,i=-1;for(let r=0;r<this._free.length;++r){const a=this._free[r];t<=a.width&&s<=a.height&&(e===null||a.y<=e.y&&a.x<=e.x)&&(e=a,i=r)}return e===null?new x:(this._free.splice(i,1),e.width<e.height?(e.width>t&&this._free.push(new x(e.x+t,e.y,e.width-t,s)),e.height>s&&this._free.push(new x(e.x,e.y+s,e.width,e.height-s))):(e.width>t&&this._free.push(new x(e.x+t,e.y,e.width-t,e.height)),e.height>s&&this._free.push(new x(e.x,e.y+s,t,e.height-s))),new x(e.x,e.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const e=this._free[s];if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)e.width+=t.width;else if(e.x===t.x&&e.width===t.width&&e.y+e.height===t.y)e.height+=t.height;else if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)e.x=t.x,e.width+=t.width;else{if(t.x!==e.x||t.width!==e.width||t.y+t.height!==e.y)continue;e.y=t.y,e.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}let $=class{constructor(t,s,e){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=e,this._binPack=new P(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const e=[],i=this._glyphSource,r=new Set,a=1/256;for(const o of s){const h=Math.floor(o*a);r.add(h)}const n=[];return r.forEach(o=>{const h=t+o;if(this._rangePromises.has(h))n.push(this._rangePromises.get(h));else{const l=i.getRange(t,o).then(()=>{this._rangePromises.delete(h)},()=>{this._rangePromises.delete(h)});this._rangePromises.set(h,l),n.push(l)}}),Promise.all(n).then(()=>{let o=this._glyphIndex[t];o||(o={},this._glyphIndex[t]=o);for(const h of s){const l=o[h];if(l){e[h]={sdf:!0,rect:l.rect,metrics:l.metrics,page:l.page,code:h};continue}const y=i.getGlyph(t,h);if(!y?.metrics)continue;const d=y.metrics;let u;if(d.width===0)u=new x(0,0,0,0);else{const c=d.width+6,g=d.height+2*3;let w=c%4?4-c%4:4,I=g%4?4-g%4:4;w===1&&(w=5),I===1&&(I=5),u=this._binPack.allocate(c+w,g+I),u.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new P(this.width-4,this.height-4),u=this._binPack.allocate(c+w,g+I));const M=this._glyphData[this._currentPage],k=y.bitmap;let U,E;if(k)for(let v=0;v<g;v++){U=c*v,E=this.width*(u.y+v+1)+u.x;for(let L=0;L<c;L++)M[E+L+1]=k.at(U+L)}}o[h]={rect:u,metrics:d,tileIDs:null,page:this._currentPage},e[h]={sdf:!0,rect:u,metrics:d,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return e})}removeGlyphs(t){for(const s in this._glyphIndex){const e=this._glyphIndex[s];if(!e)continue;let i;for(const r in e)if(i=e[r],i.tileIDs.delete(t),i.tileIDs.size===0){const a=this._glyphData[i.page],n=i.rect;let o,h;for(let l=0;l<n.height;l++)for(o=this.width*(n.y+l)+n.x,h=0;h<n.width;h++)a[o+h]=0;delete e[r],this._dirties[i.page]=!0}}}bind(t,s,e,i=0){if(!this._textures[e]){const a=new N;a.pixelFormat=j.ALPHA,a.wrapMode=G.CLAMP_TO_EDGE,a.width=this.width,a.height=this.height,this._textures[e]=new K(t,a,new Uint8Array(this.width*this.height))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(this._glyphData[e]),t.bindTexture(r,i),this._dirties[e]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}};class T{constructor(t){if(this._metrics=[],!t)return void(this._allBitmaps=null);const s=new Map;let e=0;for(;t.next();)switch(t.tag()){case 1:{const a=t.getMessage();for(;a.next();)switch(a.tag()){case 3:{const n=a.getMessage();let o,h,l,y,d,u,f;for(;n.next();)switch(n.tag()){case 1:o=n.getUInt32();break;case 2:h=n.getBytes();break;case 3:l=n.getUInt32();break;case 4:y=n.getUInt32();break;case 5:d=n.getSInt32();break;case 6:u=n.getSInt32();break;case 7:f=n.getUInt32();break;default:n.skip()}if(n.release(),o){const c=h?.length??0;this._metrics[o]={width:l,height:y,left:d,top:u,advance:f,startOffset:e,length:c},s.set(o,h),e+=c}break}default:a.skip()}a.release();break}default:t.skip()}const i=new Uint8Array(e),r=this._metrics;for(const[a,n]of s){const{startOffset:o,length:h}=r[a];if(n)for(let l=0;l<h;++l)i[o+l]=n[l]}this._allBitmaps=i}getMetrics(t){return this._metrics[t]}getBitmap(t){if(!this._allBitmaps)return;const s=this._metrics[t];if(s===void 0)return;const{startOffset:e,length:i}=s;return i!==0?new dt(this._allBitmaps,e,i):void 0}}class ut{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}let H=class{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const e=this._getFontStack(t);if(e.getRange(s))return Promise.resolve();const i=256*s,r=i+255;if(this._baseURL){const a=this._baseURL.replace("{fontstack}",t).replace("{range}",i+"-"+r);return Y(a,{responseType:"array-buffer"}).then(n=>{e.addRange(s,new T(new lt(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{e.addRange(s,new T)})}return e.addRange(s,new T),Promise.resolve()}getGlyph(t,s){const e=this._getFontStack(t);if(!e)return;const i=Math.floor(s/256),r=e.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new ut),s}};class dt{constructor(t,s,e){this._array=t,this._start=s,this.length=e}at(t){return 0<=t&&t<this.length?this._array[this._start+t]:void 0}}const ft="dasharray-";class R{constructor(t,s,e=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,e>0&&(this._maxItemSize=e),this._binPack=new P(t-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new P(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(s*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let e,i,r=this._mosaicRects[t];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(t&&t.startsWith(ft)?([e,i]=this._rasterizeDash(t),s=!0):e=this._sprites.getSpriteInfo(t),!e?.width||!e.height||e.width<0||e.height<0))return null;const a=e.width,n=e.height,[o,h,l]=this._allocateImage(a,n);return o.width<=0?null:(this._copy(o,e,h,l,s,i),r={type:"sprite",rect:o,width:a,height:n,sdf:e.sdf,simplePattern:!1,rasterizationScale:e.pixelRatio??1,samplingMode:"Linear",page:h},this._mosaicRects[t]=r,r)}getSpriteItems(t){const s={};for(const e of t)s[e.name]=this.getSpriteItem(e.name,e.repeat);return s}getMosaicItemPosition(t,s){const e=this.getSpriteItem(t,s),i=e?.rect;if(!i)return null;i.width=e.width,i.height=e.height;const r=e.width,a=e.height,n=2;return{tl:[i.x+n,i.y+n],br:[i.x+n+r,i.y+n+a],page:e.page}}bind(t,s,e=0,i=0){if(e>=this._size.length||e>=this._mosaicsData.length)return;if(!this._textures[e]){const a=new N;a.wrapMode=G.CLAMP_TO_EDGE,a.width=this._size[e][0],a.height=this._size[e][1],this._textures[e]=new K(t,a,new Uint8Array(this._mosaicsData[e].buffer))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(new Uint8Array(this._mosaicsData[e].buffer)),t.bindTexture(r,i),this._dirties[e]=!1}static _copyBits(t,s,e,i,r,a,n,o,h,l,y){let d=i*s+e,u=o*a+n;if(y){u-=a;for(let f=-1;f<=l;f++,d=((f+l)%l+i)*s+e,u+=a)for(let c=-1;c<=h;c++)r[u+c]=t[d+(c+h)%h]}else for(let f=0;f<l;f++){for(let c=0;c<h;c++)r[u+c]=t[d+c];d+=s,u+=a}}_copy(t,s,e,i,r,a){if(!this._sprites||this._sprites.loadStatus!=="loaded"||e>=this._mosaicsData.length)return;const n=new Uint32Array(a?a.buffer:this._sprites.image.buffer),o=this._mosaicsData[e],h=2,l=a?s.width:this._sprites.width;R._copyBits(n,l,s.x,s.y,o,i[0],t.x+h,t.y+h,s.width,s.height,r),this._dirties[e]=!0}_allocateImage(t,s){t+=2,s+=2;const e=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<e){const n=new x(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[t,s]]}let i=t%4?4-t%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const a=this._binPack.allocate(t+i,s+r);return a.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new P(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[a,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,e=t.match(s);if(!e)return null;const i=e[1].split(",").map(Number),r=t.slice(t.lastIndexOf("-")+1),[a,n,o]=ct(i,r);return[{x:0,y:0,width:n,height:o,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}class At{constructor(t,s,e,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=e,this._sourceDataMaxLOD=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=J(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,e=new H(s?B(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new $(1024,1024,e),this._broadcastPromise=X("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(i=>{if(this._layer&&(this._connection?.close(),this._connection=i,this._layer&&!this._connection.closed)){const r=i.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},t);Promise.all(r).catch(a=>Z(a))}})}_requestSprite(t){this._spriteSourceAbortController?.abort();const s=new AbortController;this._spriteSourceAbortController=s;const e=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,e&&(this._inputSignalEventListener=gt(s),e.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=s,r={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(a=>{Q(i),this._spriteMosaic=new R(1024,1024,250),this._spriteMosaic.setSpriteSource(a)})}async updateStyle(t){const s=[];for(const e of t)e.type===z.SPRITES_CHANGED?s.push({type:z.SPRITES_CHANGED,data:{spriteSource:null}}):s.push(e);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",s)),this._broadcastPromise}setSpriteSource(t){const s=new R(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s,e){await this._broadcastPromise,this._styleRepository=t,this._sourceDataMaxLOD=e,this._requestSprite();const i=new H(this._layer.currentStyleInfo.glyphsUrl?B(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new $(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(t,s){const e=await this._getRefKeys(t,s);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),e,s)}async fetchTilePBFs(t){const s=Object.keys(this._layer.sourceNameToSource),e={},i=await this._getRefKeys(t,e),r=[],a=[];for(let n=0;n<i.length;n++)if(i[n].value==null||s[n]==null)a.push(null);else{const o=i[n].value,h=this._getTilePayload(o,s[n],e);h.then(l=>{r.push({...l,key:o})}),a.push(h)}return Promise.all(a).then(()=>r)}async parseTileData(t,s){const e=t&&t.data;if(!e)return null;const{sourceName2DataAndRefKey:i,transferList:r}=e;return Object.keys(i).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:r}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,e){const i=S.pool.acquire(t.id),r=this._layer.sourceNameToSource[s],{level:a,row:n,col:o}=i;S.pool.release(i);try{return{protobuff:await r.requestTile(a,n,o,e),sourceName:s}}catch(h){if(tt(h))throw h;return{protobuff:null,sourceName:s}}}async _getRefKeys(t,s){const e=this._layer.sourceNameToSource,i=new Array;for(const r in e){const a=e[r].getRefKey(t,s);i.push(a)}return W(i)}_getSourcesData(t,s,e){const i=[];for(let r=0;r<s.length;r++)if(s[r].value==null||t[r]==null)i.push(null);else{const a=s[r].value,n=this._getTilePayload(a,t[r],e);i.push(n)}return W(i).then(r=>{const a={},n=[];for(let o=0;o<r.length;o++){const h=r[o].value;if(h&&h.protobuff&&h.protobuff.byteLength>0){const l=s[o].value.id;a[h.sourceName]={refKey:l,protobuff:h.protobuff},n.push(h.protobuff)}}return{sourceName2DataAndRefKey:a,transferList:n}})}}function gt(_){return()=>_.abort()}class O{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this._data=t;let e=1;const i=new Uint32Array(t);this.layerUIDs=[];const r=i[e++];for(let a=0;a<r;a++)this.layerUIDs[a]=i[e++];this.bufferDataOffset=e,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(t){this._data!=null&&(this.doPrepareForRendering(t,this._data,this.bufferDataOffset),this._data=null)}}class _t extends O{constructor(t,s){super(t,s),this.type=b.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.lineIndexStart=e[i++],this.lineIndexCount=e[i++];const r=e[i++];if(r>0){this.patternMap=new Map;for(let a=0;a<r;a++){const n=e[i++],o=e[i++],h=e[i++];this.patternMap.set(n,[o,h])}}this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=this.layer.lineMaterial;this.vao=new A(t,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}}class yt extends O{constructor(t,s){super(t,s),this.type=b.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.fillIndexStart=e[i++],this.fillIndexCount=e[i++],this.outlineIndexStart=e[i++],this.outlineIndexCount=e[i++];const r=e[i++];if(r>0){this.patternMap=new Map;for(let a=0;a<r;a++){const n=e[i++],o=e[i++],h=e[i++];this.patternMap.set(n,[o,h])}}this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.cachedMemory??0)+(this.outlineVAO?.cachedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=D(this.fillVAO),this.outlineVAO=D(this.outlineVAO)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=i[e++],y=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,l));e+=l;const d=i[e++],u=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,d));e+=d;const f=this.layer,c=f.fillMaterial,g=f.outlineMaterial;this.fillVAO=new A(t,c.getAttributeLocations(),c.getLayoutInfo(),new Map([["geometry",n]]),h),this.outlineVAO=new A(t,g.getAttributeLocations(),g.getLayoutInfo(),new Map([["geometry",y]]),u)}}class pt extends O{constructor(t,s,e){super(t,s),this.type=b.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const i=new Uint32Array(t),r=new Int32Array(t),a=new Float32Array(t);let n=this.bufferDataOffset;this.isIconSDF=!!i[n++];const o=i[n++],h=i[n++],l=i[n++],y=new S(o,h,l,0),d=i[n++];for(let g=0;g<d;g++){const w=i[n++],I=i[n++],M=i[n++];this.iconPerPageElementsMap.set(w,[I,M])}const u=i[n++];for(let g=0;g<u;g++){const w=i[n++],I=i[n++],M=i[n++];this.glyphPerPageElementsMap.set(w,[I,M])}const f=i[n++],c=i[n++];this.iconOpacity=new Int32Array(f),this.textOpacity=new Int32Array(c),n=et(i,r,a,n,this.symbols,e,y),this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.cachedMemory??0)+(this.textVAO?.cachedMemory??0)+V(this.iconOpacity)+V(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const s of this.iconPerPageElementsMap.values())t+=s[1];for(const s of this.glyphPerPageElementsMap.values())t+=s[1];return t/3}doDestroy(){this.iconVAO=D(this.iconVAO),this.textVAO=D(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=this.iconOpacity,s=this.iconVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===s.usedMemory&&s.setSubData(t,0,0,t.length);const e=this.textOpacity,i=this.textVAO.vertexBuffers.get("opacity");e.length>0&&e.byteLength===i.usedMemory&&i.setSubData(e,0,0,e.length)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=i[e++],y=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,l));e+=l;const d=i[e++],u=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,d));e+=d;const f=p.createVertex(t,m.STATIC_DRAW,this.iconOpacity.buffer),c=p.createVertex(t,m.STATIC_DRAW,this.textOpacity.buffer),g=this.layer,w=g.iconMaterial,I=g.textMaterial;this.iconVAO=new A(t,w.getAttributeLocations(),w.getLayoutInfo(),new Map([["geometry",n],["opacity",f]]),h),this.textVAO=new A(t,I.getAttributeLocations(),I.getLayoutInfo(),new Map([["geometry",y],["opacity",c]]),u)}}class mt extends O{constructor(t,s){super(t,s),this.type=b.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.circleIndexStart=e[i++],this.circleIndexCount=e[i++],this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=p.createVertex(t,m.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=p.createIndex(t,m.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=this.layer.circleMaterial;this.vao=new A(t,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}}class q extends st{constructor(t,s,e,i,r,a,n,o=null){super(t,s,e,i,r,a,4096,4096),this.styleRepository=n,this._memCache=o,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<F}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<F)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(t){let s=!1;for(const e of t){const i=this.layerData.get(e);i&&(this._usedMemory-=i.usedMemory,i.type===b.SYMBOL&&this.symbols.delete(e)&&(s=!0),i.destroy(),this.layerData.delete(e))}this._memCache?.updateSize(this.key.id,this),s&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const t=this.layerData.values();for(const s of t)if(s.hasData())return!0;return!1}dispose(){this.status!=="unloaded"&&(q._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){--this._referenced==0&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get cachedMemory(){return this._usedMemory}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(t){this.featureIndex?.clear();let s=!1;if(t){const{bucketsWithData:e,emptyBuckets:i}=t,r=this._createRenderBuckets(e);if(i&&i.byteLength>0){const a=new Uint32Array(i);for(const n of a)this._deleteLayerData(n)}for(const[a,n]of r)this._deleteLayerData(a),n.type===b.SYMBOL&&(this.symbols.set(a,n.symbols),s=!0),this._usedMemory+=n.usedMemory,this.layerData.set(a,n);this._memCache?.updateSize(this.key.id,this)}this._hasSymbolBuckets=!1;for(const e of this.layerData.values())e.type===b.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(s){s.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t){super.setTransform(t);const s=this.resolution/(t.resolution*t.pixelRatio),e=this.width/this.rangeX*s,i=this.height/this.rangeY*s,r=[0,0];t.toScreen(r,[this.x,this.y]);const a=this.transforms.tileUnitsToPixels;it(a),rt(a,a,r),at(a,a,Math.PI*t.rotation/180),nt(a,a,[e,i,1])}_createTransforms(){return{displayViewScreenMat3:C(),tileMat3:C(),tileUnitsToPixels:C()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;for(const e of t.values())s.has(e)||(e.destroy(),s.add(e));t.clear()}_createRenderBuckets(t){const s=new Map,e=new Map;for(const i of t){const r=this._deserializeBucket(i,e);for(const a of r.layerUIDs)s.set(a,r)}return s}_deserializeBucket(t,s){let e=s.get(t);if(e)return e;switch(new Uint32Array(t)[0]){case b.FILL:e=new yt(t,this.styleRepository);break;case b.LINE:e=new _t(t,this.styleRepository);break;case b.SYMBOL:e=new pt(t,this.styleRepository,this);break;case b.CIRCLE:e=new mt(t,this.styleRepository)}return s.set(t,e),e}_deleteLayerData(t){if(!this.layerData.has(t))return;const s=this.layerData.get(t);this._usedMemory-=s.usedMemory,s.destroy(),this.layerData.delete(t)}}class Mt extends ht{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=S.pool.acquire(t),e=s.level===0?null:S.getId(s.level-1,s.row>>1,s.col>>1,s.world);return S.pool.release(s),e}getTileCoverage(t,s,e=!0,i){const r=super.getTileCoverage(t,s,e,i);if(!r)return r;const a=1<<r.lodInfo.level;return r.spans=r.spans.filter(n=>n.row>=0&&n.row<a),r}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let e,i;for(let r=0;r<s.length-1;r++)if(i=s[r+1],t>i.scale)return e=s[r],e.level+(e.scale-t)/(e.scale-i.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(t[0].level===0)s=t.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=ot.create({size:e,spatialReference:i}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}))}for(let e=0;e<s.length;e++)this._levelByScale[s[e].scale]=s[e].level;this._fullCacheLodInfos=s}}export{At as p,Mt as t,q as y};
